/* Copyright (c) 2020 vesoft inc. All rights reserved.
 *
 * This source code is licensed under Apache 2.0 License,
 * attached with Common Clause Condition 1.0, found in the LICENSES directory.
 */

#include "meta/processors/sessionMan/SessionManagerProcessor.h"

namespace nebula {
namespace meta {

void CreateSessionProcessor::process(const cpp2::CreateSessionReq& req) {
    folly::SharedMutex::WriteHolder wHolder(LockUtils::sessionLock());
    const auto& user = req.get_user();
    auto ret = userExist(user);
    if (!ret.ok()) {
        handleErrorCode(cpp2::ErrorCode::E_NOT_FOUND);
        onFinished();
        return;
    }

    cpp2::Session session;
    // The sessionId is generated by microsecond timestamp
    session.session_id = time::WallClock::fastNowInMicroSec();
    session.create_time = session.session_id;
    session.update_time = session.create_time;
    session.user_name = user;
    session.graph_addr = req.get_graph_addr();
    session.client_ip = req.get_client_ip();

    std::vector<kvstore::KV> data;
    data.emplace_back(MetaServiceUtils::sessionKey(session.session_id),
                      MetaServiceUtils::sessionVal(session));
    resp_.set_session(session);
    doSyncPutAndUpdate(std::move(data));
}


void UpdateSessionsProcessor::process(const cpp2::UpdateSessionsReq& req) {
    folly::SharedMutex::WriteHolder wHolder(LockUtils::sessionLock());
    std::vector<kvstore::KV> data;
    for (auto& session : req.get_sessions()) {
        auto sessionId = session.session_id;
        auto sessionKey = MetaServiceUtils::sessionKey(sessionId);
        auto ret = doGet(sessionKey);
        if (!ret.ok()) {
            LOG(WARNING) << "Session id `" << sessionId << "' not found";
            handleErrorCode(cpp2::ErrorCode::E_NOT_FOUND);
            onFinished();
            return;
        }

        data.emplace_back(MetaServiceUtils::sessionKey(sessionId),
                          MetaServiceUtils::sessionVal(session));
    }
    doSyncPutAndUpdate(std::move(data));
}


void ListSessionsProcessor::process(const cpp2::ListSessionsReq&) {
    folly::SharedMutex::ReadHolder rHolder(LockUtils::sessionLock());
    auto &prefix = MetaServiceUtils::sessionPrefix();
    std::unique_ptr<kvstore::KVIterator> iter;
    auto ret = kvstore_->prefix(kDefaultSpaceId, kDefaultPartId, prefix, &iter);
    if (ret != kvstore::ResultCode::SUCCEEDED) {
        handleErrorCode(MetaCommon::to(ret));
        onFinished();
        return;
    }

    std::vector<cpp2::Session> sessions;
    while (iter->valid()) {
        auto session = MetaServiceUtils::parseSessionVal(iter->val());
        VLOG(3) << "List session: " << session.session_id;
        sessions.emplace_back(std::move(session));
        iter->next();
    }
    resp_.set_sessions(std::move(sessions));
    for (auto &session : resp_.get_sessions()) {
        LOG(INFO) << "resp list session: " << session.session_id;
    }
    onFinished();
}


void GetSessionProcessor::process(const cpp2::GetSessionReq& req) {
    folly::SharedMutex::ReadHolder rHolder(LockUtils::sessionLock());
    auto sessionId = req.get_session_id();
    auto sessionKey = MetaServiceUtils::sessionKey(sessionId);
    auto ret = doGet(sessionKey);
    if (!ret.ok()) {
        LOG(ERROR) << "Session id `" << sessionId << "' not found";
        handleErrorCode(cpp2::ErrorCode::E_NOT_FOUND);
        onFinished();
        return;
    }

    auto session = MetaServiceUtils::parseSessionVal(ret.value());
    resp_.set_session(std::move(session));
    onFinished();
}

void RemoveSessionProcessor::process(const cpp2::RemoveSessionReq& req) {
    folly::SharedMutex::WriteHolder wHolder(LockUtils::sessionLock());
    auto sessionId = req.get_session_id();
    auto sessionKey = MetaServiceUtils::sessionKey(sessionId);
    auto ret = doGet(sessionKey);
    if (!ret.ok()) {
        LOG(ERROR) << "Session id `" << sessionId << "' not found";
        handleErrorCode(cpp2::ErrorCode::E_NOT_FOUND);
        onFinished();
        return;
    }

    doSyncMultiRemoveAndUpdate({sessionKey});
}

}  // namespace meta
}  // namespace nebula
